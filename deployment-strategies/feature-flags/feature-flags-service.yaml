---
# Feature Flags ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: feature-flags
  namespace: microservices
  labels:
    app: feature-flags
    component: configuration
data:
  flags.json: |
    {
      "features": {
        "analytics": {
          "enabled": true,
          "rollout": 100,
          "description": "Advanced analytics and reporting",
          "environments": ["development", "staging", "production"],
          "constraints": {
            "userPercentage": 100,
            "regions": ["us", "eu", "asia"],
            "minVersion": "1.0.0"
          }
        },
        "caching": {
          "enabled": true,
          "rollout": 80,
          "description": "Advanced caching system",
          "environments": ["staging", "production"],
          "constraints": {
            "userPercentage": 80,
            "regions": ["us", "eu"],
            "minVersion": "1.1.0"
          }
        },
        "rateLimiting": {
          "enabled": true,
          "rollout": 50,
          "description": "API rate limiting and throttling",
          "environments": ["production"],
          "constraints": {
            "userPercentage": 50,
            "regions": ["us"],
            "minVersion": "1.2.0"
          }
        },
        "newUserInterface": {
          "enabled": false,
          "rollout": 10,
          "description": "New user interface design",
          "environments": ["development"],
          "constraints": {
            "userPercentage": 10,
            "regions": ["us"],
            "minVersion": "2.0.0"
          }
        },
        "machineLearning": {
          "enabled": false,
          "rollout": 5,
          "description": "ML-based recommendations",
          "environments": ["development"],
          "constraints": {
            "userPercentage": 5,
            "regions": ["us"],
            "minVersion": "2.1.0"
          }
        },
        "realTimeNotifications": {
          "enabled": true,
          "rollout": 75,
          "description": "Real-time push notifications",
          "environments": ["staging", "production"],
          "constraints": {
            "userPercentage": 75,
            "regions": ["us", "eu"],
            "minVersion": "1.3.0"
          }
        }
      },
      "globalSettings": {
        "environment": "production",
        "version": "1.4.0",
        "region": "us",
        "lastUpdated": "2025-08-09T17:00:00Z",
        "updateSource": "automated-deployment"
      },
      "rollbackSettings": {
        "autoRollback": true,
        "errorThreshold": 5,
        "rollbackDelay": 300,
        "emergencyShutoff": false
      }
    }

---
# Feature Flags Service
apiVersion: apps/v1
kind: Deployment
metadata:
  name: feature-flags-service
  namespace: microservices
  labels:
    app: feature-flags-service
    component: configuration
spec:
  replicas: 3
  selector:
    matchLabels:
      app: feature-flags-service
  template:
    metadata:
      labels:
        app: feature-flags-service
        component: configuration
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9090"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: feature-flags-service
        image: node:18-alpine
        ports:
        - containerPort: 3000
          name: http
        - containerPort: 9090
          name: metrics
        env:
        - name: SERVICE_NAME
          value: "feature-flags-service"
        - name: ENVIRONMENT
          value: "production"
        volumeMounts:
        - name: feature-flags-config
          mountPath: /app/config
          readOnly: true
        command: ["node", "-e"]
        args:
          - |
            const http = require('http');
            const fs = require('fs');
            const url = require('url');
            
            let requestCount = 0;
            const startTime = Date.now();
            const serviceName = process.env.SERVICE_NAME || 'feature-flags-service';
            const environment = process.env.ENVIRONMENT || 'production';
            
            // Load feature flags configuration
            let featureFlags = {};
            try {
              const configData = fs.readFileSync('/app/config/flags.json', 'utf8');
              featureFlags = JSON.parse(configData);
            } catch (error) {
              console.error('Failed to load feature flags:', error.message);
              featureFlags = { features: {}, globalSettings: {}, rollbackSettings: {} };
            }
            
            // Feature flag evaluation logic
            function evaluateFeatureFlag(flagName, context = {}) {
              const flag = featureFlags.features[flagName];
              
              if (!flag) {
                return {
                  enabled: false,
                  reason: 'Flag not found'
                };
              }
              
              // Check if feature is globally enabled
              if (!flag.enabled) {
                return {
                  enabled: false,
                  reason: 'Feature globally disabled'
                };
              }
              
              // Check environment constraint
              if (flag.environments && !flag.environments.includes(context.environment || environment)) {
                return {
                  enabled: false,
                  reason: `Environment ${context.environment || environment} not allowed`
                };
              }
              
              // Check user percentage rollout
              const userPercentage = flag.constraints?.userPercentage || 100;
              const userId = context.userId || 'default';
              const userHash = hashCode(userId) % 100;
              
              if (userHash >= userPercentage) {
                return {
                  enabled: false,
                  reason: `User not in rollout percentage (${userPercentage}%)`
                };
              }
              
              // Check region constraint
              if (flag.constraints?.regions && context.region) {
                if (!flag.constraints.regions.includes(context.region)) {
                  return {
                    enabled: false,
                    reason: `Region ${context.region} not allowed`
                  };
                }
              }
              
              // Check version constraint
              if (flag.constraints?.minVersion && context.version) {
                if (compareVersions(context.version, flag.constraints.minVersion) < 0) {
                  return {
                    enabled: false,
                    reason: `Version ${context.version} below minimum ${flag.constraints.minVersion}`
                  };
                }
              }
              
              return {
                enabled: true,
                reason: 'All constraints satisfied',
                rollout: flag.rollout
              };
            }
            
            // Utility functions
            function hashCode(str) {
              let hash = 0;
              for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
              }
              return Math.abs(hash);
            }
            
            function compareVersions(version1, version2) {
              const v1parts = version1.split('.').map(Number);
              const v2parts = version2.split('.').map(Number);
              
              for (let i = 0; i < Math.max(v1parts.length, v2parts.length); i++) {
                const v1part = v1parts[i] || 0;
                const v2part = v2parts[i] || 0;
                
                if (v1part > v2part) return 1;
                if (v1part < v2part) return -1;
              }
              return 0;
            }
            
            const server = http.createServer((req, res) => {
              const parsedUrl = url.parse(req.url, true);
              requestCount++;
              
              res.setHeader('Access-Control-Allow-Origin', '*');
              res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
              res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
              res.setHeader('Content-Type', 'application/json');
              
              if (req.method === 'OPTIONS') {
                res.writeHead(200);
                res.end();
                return;
              }
              
              if (parsedUrl.pathname === '/health') {
                res.writeHead(200);
                res.end(JSON.stringify({
                  service: serviceName,
                  status: 'healthy',
                  uptime: Date.now() - startTime,
                  flagsLoaded: Object.keys(featureFlags.features || {}).length,
                  environment: environment,
                  timestamp: new Date().toISOString()
                }));
                return;
              }
              
              if (parsedUrl.pathname === '/flags') {
                // Return all feature flags
                res.writeHead(200);
                res.end(JSON.stringify({
                  service: serviceName,
                  flags: featureFlags.features,
                  globalSettings: featureFlags.globalSettings,
                  timestamp: new Date().toISOString()
                }));
                return;
              }
              
              if (parsedUrl.pathname.startsWith('/flag/')) {
                // Evaluate specific feature flag
                const flagName = parsedUrl.pathname.substring(6);
                const context = {
                  userId: parsedUrl.query.userId,
                  environment: parsedUrl.query.environment,
                  region: parsedUrl.query.region,
                  version: parsedUrl.query.version
                };
                
                const evaluation = evaluateFeatureFlag(flagName, context);
                
                res.writeHead(200);
                res.end(JSON.stringify({
                  service: serviceName,
                  flagName: flagName,
                  evaluation: evaluation,
                  context: context,
                  timestamp: new Date().toISOString()
                }));
                return;
              }
              
              if (parsedUrl.pathname === '/evaluate') {
                // Bulk evaluation endpoint
                if (req.method === 'POST') {
                  let body = '';
                  req.on('data', chunk => {
                    body += chunk.toString();
                  });
                  req.on('end', () => {
                    try {
                      const requestData = JSON.parse(body);
                      const context = requestData.context || {};
                      const flagNames = requestData.flags || [];
                      
                      const evaluations = {};
                      flagNames.forEach(flagName => {
                        evaluations[flagName] = evaluateFeatureFlag(flagName, context);
                      });
                      
                      res.writeHead(200);
                      res.end(JSON.stringify({
                        service: serviceName,
                        evaluations: evaluations,
                        context: context,
                        timestamp: new Date().toISOString()
                      }));
                    } catch (error) {
                      res.writeHead(400);
                      res.end(JSON.stringify({
                        error: 'Invalid JSON',
                        message: error.message
                      }));
                    }
                  });
                  return;
                } else {
                  res.writeHead(405);
                  res.end(JSON.stringify({ error: 'Method not allowed' }));
                  return;
                }
              }
              
              if (parsedUrl.pathname === '/reload') {
                // Reload feature flags configuration
                try {
                  const configData = fs.readFileSync('/app/config/flags.json', 'utf8');
                  featureFlags = JSON.parse(configData);
                  res.writeHead(200);
                  res.end(JSON.stringify({
                    service: serviceName,
                    message: 'Feature flags reloaded successfully',
                    flagsCount: Object.keys(featureFlags.features || {}).length,
                    timestamp: new Date().toISOString()
                  }));
                } catch (error) {
                  res.writeHead(500);
                  res.end(JSON.stringify({
                    error: 'Failed to reload feature flags',
                    message: error.message
                  }));
                }
                return;
              }
              
              // Default response
              res.writeHead(404);
              res.end(JSON.stringify({
                error: 'Not Found',
                availableEndpoints: [
                  '/health',
                  '/flags',
                  '/flag/{flagName}',
                  '/evaluate',
                  '/reload'
                ]
              }));
            });
            
            server.listen(3000, () => {
              console.log(`${serviceName} listening on port 3000`);
              console.log(`Environment: ${environment}`);
              console.log(`Feature flags loaded: ${Object.keys(featureFlags.features || {}).length}`);
            });
            
            // Metrics server
            const metricsServer = http.createServer((req, res) => {
              if (req.url === '/metrics') {
                const uptime = Math.floor((Date.now() - startTime) / 1000);
                const flagsCount = Object.keys(featureFlags.features || {}).length;
                const metrics = `# HELP feature_flags_requests_total Total requests\\n# TYPE feature_flags_requests_total counter\\nfeature_flags_requests_total{service="${serviceName}",environment="${environment}"} ${requestCount}\\n# HELP feature_flags_uptime_seconds Uptime\\n# TYPE feature_flags_uptime_seconds gauge\\nfeature_flags_uptime_seconds{service="${serviceName}",environment="${environment}"} ${uptime}\\n# HELP feature_flags_count Total feature flags\\n# TYPE feature_flags_count gauge\\nfeature_flags_count{service="${serviceName}",environment="${environment}"} ${flagsCount}`;
                res.writeHead(200, { 'Content-Type': 'text/plain' });
                res.end(metrics);
              } else {
                res.writeHead(404);
                res.end();
              }
            });
            
            metricsServer.listen(9090, () => {
              console.log(`Metrics server listening on port 9090`);
            });
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
      volumes:
      - name: feature-flags-config
        configMap:
          name: feature-flags

---
# Feature Flags Service
apiVersion: v1
kind: Service
metadata:
  name: feature-flags-service
  namespace: microservices
  labels:
    app: feature-flags-service
    component: configuration
spec:
  type: ClusterIP
  ports:
  - port: 3000
    targetPort: 3000
    name: http
  - port: 9090
    targetPort: 9090
    name: metrics
  selector:
    app: feature-flags-service
